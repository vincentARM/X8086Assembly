Au chapitre précédent, nous avons vu que la soustraction pouvait donner un résultat négatif. Nous allons donc voir comment sont traités les nombres negatifs par le processeur. <br>
Pour cela, les ingénieurs ont décidés que la plage 1 à 2 puissance 31 - 1 serait dédiée aux nombres positifs (donc de 1 à 2 147 483 647) et que la plage 2 puissance 31 à 2 puissance 32 - 1 aux nombres négatifs (soit de 2 147 483 648 à  4 294 967 295‬). <br>
Et les nombres négatifs seraient codés en complement de 2 (plus exactement en complement de 2 puissance 32) cad en faisant la difference entre 4 294 967 296‬ et leur valeur positive.<br>
Par exemple - 1 sera codé 4 294 967 296‬ - 1 = 4 294 967 295‬. ouh la la !! cela va nous obliger à faire des calculs compliqués. Non pas du tout car d'une part l'assembleur dispose de l'instruction neg qui inverse la valeur d'un registre et d'autre part nasm comprend bien l'instruction mov eax,-1  ou tout autre valeur. <br>
Mais pour voir les résultats des calculs avec des nombres négatifs, il nous faut écrire une autre routine de conversion en base 10 qui tient compte maintenant du signe de la valeur à afficher. Mais pourquoi ne pas adapter la précedente routine de conversion décimale. Et bien, il n'y a aucun moyen de savoir si un registre travaille avec des valeurs strictement positives dans la plage 1 à 4 294 967 295‬ ou s'il peut s'agir de valeurs positives ou négatives. Il n'y a qu'un seul être au monde qui le sache c'est <b>vous le programmeur</b>. Et donc vous seul pouvez décider d'utiliser la routine de conversion décimale non signée ou la routine signée que nous allons écrire. <br>
On ne va tout réinventer, nous allons copier la routine conversion10 vers la routine conversion10S et nous allons tester le signe de la valeur à convertir avec l'instruction js. Si le signe est négatif, nous inversons la valeur et nous effectuons la conversion en caractère ascii comme dans la précedente routine. Il faudra conserver cette indication de signe pour à la fin ajouter le signe dans la zone receptrice et devant les caractères ascii des chiffres.<br>
Puis dans le programme pgm7.asm, nous allons effectuer plusieurs vérifications sur les opérations arithmètiques pour examiner les résultats.
Dans ce programme, nous avons ajouté la routine d'affichage afficherReg10S qui appelle la routine de conversion conversion10S. J'ai laissé le même message d'entête mais j'aurais pu le modifier pour préciser que l'affichage se fait pour des valeurs signées.<br>
Dans la routine conversion10S, nous mettons par defaut le signe + dans le registre esi et nous comparons la valeur à afficher à zéro et si l'indicateur signe est positionné nous mettons le signe - dans le registre esi et nous inversons la valeur avec l'instruction neg eax. <br>
La première boucle  de la routine de conversion reste inchangée et à la fin de cette boucle nous ajoutons simplement le stockage du signe avant les chiffres que nous venons d'extraire. Le signe est contenu dans le registre esi mais pour stocker un seul octet il nous faut d'abord copier le registre esi dans le registre edx puis stocker en mémoire la partie dl du registre.<br>
Dans le code principal, nous effectuons comme précedement la soustraction 5 - 15 et nous affichons le resultat avec la nouvelle routine. Le résultat -10 est correct.
Ensuite nous mettons la valeur -1 dans le registre eax et nous l'affichons avec les 2 routines : la routine signée affiche bien -1 et la routine non signée affiche 4294967295 comme prévu. <br>
Ensuite nous vérifions les resultats de l'addition de 2 nombres négatifs puis l'addition de grands nombre pour voir le positionnement des flags.
Vous remarquerez que nous remettons chaque fois la valeur du registre eax et que nous essayons de ne pas fair d'appel à une routine d'affichage entre l'instruction à vérifier et l'indicateur à tester. En effet il ne faut pas oublier que nos routines d'affichage d'un registre retourne la longueur affichée dans le registre eax. Ce n'est donc pas une bonne idée et donc il faut sauvegarder le registre eax et le restaurer dans la routine d'affichage. Dans les routines de conversion, on peut laisser le retour de la longueur dans le registre eax car cela peut être utile. <br>
De plus l'appel à une routine modifie les indicateurs puisqu'il y a des instructions d'addition ou de soustraction et des comparaisons qui modifie l'état des indicateurs. Pour avoir des routines totalement neutres par rapport au reste du programme il faut en plus de la sauvegarde des registres, sauvegarder l'état des indicateurs par une instruction pushf et les restaurer par popf. Nous verrons plus précisement tout cela dans un futur chapitre.<br>

Reste le cas de la multiplication et de la division. La documentation indique que pour les valeurs signées il faut utiliser les instructions imul et idiv. Pour de petits calculs, je n'ai pas vu de différences entre les résultats. Pour des calculs avec des nombres très grands, les calculs doivent être différents mais comme il faut raisonner sur des nombres de 64 bits, il est difficile de montrer en quoi l'utilisation des routines mul et div est erronée. Dans l'immédiat, cela ne nous pose pas de problème mais il faudra être vigilant sur ces opérations dès lors que les programmes devront effectuer des calculs sur des nombres grands (autour des limites de la plage negatif/positif par exemple et au délà).


